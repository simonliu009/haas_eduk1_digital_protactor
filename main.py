import sh1106
import utime, math
import sys
from driver import SPI
from driver import GPIO
from kalman import KalmanAngle
from mpu6050 import MPU6050


# [components/py_engine/framework/mpu6050.py]
# (https://gitee.com/alios-things/AliOS-Things/blob/master/components/py_engine/framework/mpu6050.py)

# Globals
last_read_time = 0.0
# 从'-'到'9'的ascii字符
font16 = [
[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00],
[0x00,0x00,0x02,0x04,0x04,0x04,0x08,0x08,0x10,0x10,0x10,0x20,0x20,0x40,0x40,0x00],
[0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00],
[0x00,0x00,0x00,0x08,0x38,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00],
[0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x02,0x04,0x08,0x10,0x20,0x42,0x7E,0x00,0x00],
[0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x04,0x18,0x04,0x02,0x42,0x42,0x3C,0x00,0x00],
[0x00,0x00,0x00,0x04,0x0C,0x0C,0x14,0x24,0x24,0x44,0x7F,0x04,0x04,0x1F,0x00,0x00],
[0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x78,0x44,0x02,0x02,0x42,0x44,0x38,0x00,0x00],
[0x00,0x00,0x00,0x18,0x24,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x22,0x1C,0x00,0x00],
[0x00,0x00,0x00,0x7E,0x42,0x04,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x00,0x00],
[0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00],
[0x00,0x00,0x00,0x38,0x44,0x42,0x42,0x42,0x46,0x3A,0x02,0x02,0x24,0x18,0x00,0x00]
]

font32 = [
[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,0x02,0x06,0x04,0x0C,0x08,0x18,0x10,0x30,0x20,0x60,0x40,0x00,0x00],
[0x00,0x00,0x00,0x02,0x06,0x04,0x0C,0x08,0x18,0x10,0x30,0x20,0x60,0x40,0xC0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x06,0x0C,0x18,0x18,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x18,0x18,0x0C,0x06,0x03,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x20,0x30,0x18,0x18,0x08,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x08,0x18,0x18,0x30,0x20,0xC0,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x1F,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x03,0x1F,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xC0,0xF8,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x08,0x10,0x20,0x20,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x02,0x04,0x08,0x10,0x20,0x3F,0x3F,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x38,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x04,0x04,0x04,0x0C,0xF8,0xF8,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x30,0x30,0x18,0x07,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x60,0x30,0x18,0x18,0x18,0x18,0x18,0x30,0x60,0xC0,0x70,0x18,0x08,0x0C,0x0C,0x0C,0x0C,0x08,0x18,0x30,0xC0,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x02,0x04,0x04,0x08,0x08,0x10,0x30,0x20,0x40,0x7F,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0xE0,0xE0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0xFC,0x60,0x60,0x60,0x60,0x60,0xFC,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x0F,0x10,0x10,0x10,0x10,0x10,0x10,0x13,0x14,0x18,0x10,0x00,0x00,0x00,0x00,0x30,0x30,0x20,0x20,0x18,0x07,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x30,0x18,0x08,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x18,0x30,0xC0,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x0C,0x08,0x18,0x10,0x10,0x30,0x33,0x36,0x38,0x38,0x30,0x30,0x30,0x30,0x30,0x18,0x18,0x0C,0x0E,0x03,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0xE0,0x30,0x18,0x08,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x08,0x18,0x30,0xE0,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x10,0x30,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x40,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x0C,0x18,0x30,0x30,0x30,0x38,0x38,0x1E,0x0F,0x07,0x18,0x30,0x30,0x60,0x60,0x60,0x60,0x60,0x30,0x18,0x07,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x08,0x18,0x20,0xC0,0xF0,0x78,0x38,0x1C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0xC0,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x18,0x30,0x30,0x60,0x60,0x60,0x60,0x60,0x60,0x70,0x30,0x18,0x0F,0x00,0x00,0x00,0x00,0x30,0x30,0x30,0x0F,0x00,0x00,0x00,0x00],
[0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x20,0x10,0x18,0x08,0x0C,0x0C,0x0C,0x0C,0x0C,0x1C,0x2C,0x6C,0x8C,0x0C,0x18,0x18,0x10,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00]
]
# These are the filtered angles
last_x_angle = 0.0          
last_y_angle = 0.0
last_z_angle = 0.0  

# Calibrated measurements to offset some bias or error in the readings.
calib_x_accel = 0.0 
calib_y_accel = 0.0 
calib_z_accel = 0.0 
calib_x_gyro  = 0.0 
calib_y_gyro  = 0.0 
calib_z_gyro = 0.0

# 用于校准的默认偏移量，可根据开发板的具体情况微调
offset = 4.7

def _get_ch32(ch):
    data = []
    n = ord(ch) - ord('-')
    data = font32[n * 2] + font32[n * 2 + 1]
    return data


def _get_ch16(ch):
    data = []
    n = ord(ch) - ord('-')
    data = font16[n]
    return data

def text32(oled, string, x_axis, y_axis):
    offset = 0
    for k in string:
        byte_data = _get_ch32(k)
        for y in range(0, 32):
            a = bin(byte_data[y]).replace('0b', '')
            while len(a) < 8:
                a = '0' + a

            b = bin(byte_data[y + 32]).replace('0b', '')
            while len(b) < 8:
                b = '0' + b
            for x in range(0, 8):
                oled.pixel(x_axis + offset + x, y + y_axis, int(a[x]))
                oled.pixel(x_axis + offset + x + 8, y + y_axis, int(b[x]))
        offset += 16

def text16(oled, string, x_axis, y_axis):
    offset = 0
    bytes_size = 16
    for k in string:
        byte_data = _get_ch16(k)
        for y in range(0, bytes_size):
            a = bin(byte_data[y]).replace('0b', '')
            while len(a) < 8:
                a = '0' + a
            for x in range(0, 8):
                oled.pixel(x_axis + offset + x, y + y_axis, int(a[x]))
        offset += 8

def set_last_read_angles(time, x, y):
    global last_read_time, last_x_angle, last_y_angle
    last_read_time = time
    last_x_angle = x 
    last_y_angle = y
    #last_z_angle = z

# accelerometer data can't be used to calculate 'yaw' angles or rotation around z axis.
def acc_angle(Ax, Ay, Az):
    radToDeg = 180/3.14159
    ax_angle = math.atan(Ay/math.sqrt(math.pow(Ax,2) + math.pow(Az, 2)))*radToDeg
    ay_angle = math.atan((-1*Ax)/math.sqrt(math.pow(Ay,2) + math.pow(Az, 2)))*radToDeg
    return (ax_angle, ay_angle)

def gyr_angle(Gx, Gy, Gz, dt):
    gx_angle = Gx*dt + last_x_angle
    gy_angle = Gy*dt + last_y_angle
    gz_angle = Gz*dt + last_z_angle
    return (gx_angle, gy_angle, gz_angle)

  # A complementary filter to determine the change in angle by combining accelerometer and gyro values. Alpha depends on the sampling rate...
def c_filtered_angle(ax_angle, ay_angle, gx_angle, gy_angle):
    alpha = 0.90
    c_angle_x = alpha*gx_angle + (1.0 - alpha)*ax_angle
    c_angle_y = alpha*gy_angle + (1.0 - alpha)*ay_angle
    return (c_angle_x, c_angle_y)

 # Kalman filter to determine the change in angle by combining accelerometer and gyro values. 
def k_filtered_angle(ax_angle, ay_angle, Gx, Gy, dt):
    k_angle_x = kalmanX.getAngle(ax_angle, Gx, dt)
    k_angle_y = kalmanY.getAngle(ay_angle, Gy, dt)
    return (k_angle_x, k_angle_y)

def read_MPU6050():
    ac = []
    gy = []
    ac = mpu6050Dev.get_Accelerometer()
    gy = mpu6050Dev.get_Gyroscope()
    return (ac[0], ac[1], ac[2], gy[0], gy[1], gy[2])

def calibrate_sensors():
    x_accel = 0
    y_accel = 0
    z_accel = 0
    x_gyro  = 0
    y_gyro  = 0
    z_gyro = 0
    ac = []
    gy = []
    #print("Starting Calibration")

    #Discard the first set of values read from the IMU
    ac = mpu6050Dev.get_Accelerometer()
    gy = mpu6050Dev.get_Gyroscope()

    # Read and average the raw values from the IMU
    calibrate_cnt = 100
    for i in range(calibrate_cnt): 
        ac = mpu6050Dev.get_Accelerometer()
        gy = mpu6050Dev.get_Gyroscope()
        x_accel += ac[0]
        y_accel += ac[1]
        z_accel += ac[2]
        x_gyro  += gy[0]
        y_gyro  += gy[1]
        z_gyro  += gy[2]
        utime.sleep_ms(10)
    
    x_accel /= calibrate_cnt
    y_accel /= calibrate_cnt
    z_accel /= calibrate_cnt
    x_gyro  /= calibrate_cnt
    y_gyro  /= calibrate_cnt
    z_gyro  /= calibrate_cnt

    # Store the raw calibration values globally
    calib_x_accel = x_accel
    calib_y_accel = y_accel
    calib_z_accel = z_accel
    calib_x_gyro  = x_gyro
    calib_y_gyro  = y_gyro
    calib_z_gyro  = z_gyro

    print("---=== Finishing Calibration ===---")

spi0 = SPI()
spi0.open("oled_spi")
print("SPI init finished")

gpio_dc = GPIO()
gpio_dc.open("oled_dc")

gpio_res = GPIO()
gpio_res.open("oled_res")
print("GPIO opened")

display = sh1106.SH1106_SPI(width=132, height=64, spi=spi0, dc = gpio_dc, res = gpio_res)

display.fill(0)
display.text("Init MPU6050", 10, 30, 1)
display.show()
utime.sleep_ms(1500)
mpu6050Dev = MPU6050()
mpu6050Dev.open("mpu6050")
mpu6050Dev.init()
print("mpu6050 init finished")
display.fill(0)
display.text("MPU6050 init OK", 0, 20, 1)
display.text("Calibrate sensor", 0, 40, 1)
display.show()
calibrate_sensors()

kalmanX = KalmanAngle()
kalmanY = KalmanAngle()


def main():
    ac = []
    gy = []
    ystr = ""
    while (True):
        
        t_now = utime.ticks_ms()
        dt = (t_now - last_read_time)/1000.0
        acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z = read_MPU6050()

        #Full scale range +/- 250 degree/C as per sensitivity scale factor. The is linear acceleration in each of the 3 directions ins g's
        Ax = acc_x/16384.0
        Ay = acc_y/16384.0
        Az = acc_z/16384.0
        
        # This is angular velocity in each of the 3 directions 
        Gx = (gyro_x - calib_x_gyro)/131.0
        Gy = (gyro_y - calib_y_gyro)/131.0
        Gz = (gyro_z - calib_z_gyro)/131.0

        acc_angles = acc_angle(Ax, Ay, Az) # Calculate angle of inclination or tilt for the x and y axes with acquired acceleration vectors
        gyr_angles = gyr_angle(Gx, Gy, Gz, dt) # Calculate angle of inclination or tilt for x,y and z axes with angular rates and dt 
        (c_angle_x, c_angle_y) = c_filtered_angle(acc_angles[0], acc_angles[1], gyr_angles[0], gyr_angles[1]) # filtered tilt angle i.e. what we're after
        (k_angle_x, k_angle_y) = k_filtered_angle(acc_angles[0], acc_angles[1], Gx, Gy, dt)

        set_last_read_angles(t_now, c_angle_x, c_angle_y)
        c_angle_y += offset
        ystr = ("{:.1f}".format(c_angle_y))
        display.fill(0)
        # 字号 8（速度很快）
        # display.text(ystr, 55, 30, 1)

        # 字号 16（速度慢，有10s左右延时）
        text16(display, ystr, 50, 24)
        
        # 字号 32（速度慢，有10s左右延时）
        # text32(display,ystr,32,16)

        display.show()
        utime.sleep_ms(10)
    mpu6050Dev.close()
    print("test mpu6050 success!")



if __name__ == "__main__":
    main()
